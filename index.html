<!DOCTYPE html>
<html>
<head>
    <title>Mars Spherical Grid</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #controls { position: absolute; top: 10px; left: 10px; z-index: 100; color: white; }
        #popup {
            position: absolute;
            background: rgba(255,255,255,0.9);
            padding: 8px;
            border-radius: 4px;
            display: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
<div id="controls">
    <select id="subdivisions">
        <option value="32">Low</option>
        <option value="64" selected>Medium</option>
        <option value="128">High</option>
    </select>
</div>
<div id="popup"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
        let scene, camera, renderer, sphere;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isDragging = false;
        let previousPosition = { x: 0, y: 0 };
        let currentFaceIndex = null;
        let lastClickedIndex = null;
        const textureLoader = new THREE.TextureLoader();

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            createSphere(64);
            camera.position.z = 15;

            // Lighting
            const light = new THREE.DirectionalLight(0xffffff, 0.5);
            light.position.set(5, 3, 5);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            // Event listeners
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('click', onClick);
            window.addEventListener('resize', onResize);
            document.getElementById('subdivisions').addEventListener('change', updateSubdivisions);
        }

        function createSphere(subdivisions) {
            if (sphere) {
                scene.remove(sphere);
                sphere.geometry.dispose();
                sphere.material.dispose();
            }

            // Load Mars texture
            textureLoader.load('mars4k.jpg', (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;

                const geometry = new THREE.SphereGeometry(5, subdivisions, subdivisions);
                const material = new THREE.MeshPhongMaterial({
                    map: texture,
                    bumpScale: 0.05,
                    specular: 0x111111,
                    shininess: 5
                });

                sphere = new THREE.Mesh(geometry, material);
                scene.add(sphere);
            }, undefined, (err) => {
                console.error('Error loading texture:', err);
            });
        }

        function updateSubdivisions(e) {
            createSphere(parseInt(e.target.value));
        }

        function onMouseDown(e) {
            isDragging = true;
            previousPosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(sphere);

            if (intersects.length > 0) {
                currentFaceIndex = intersects[0].faceIndex;
            } else {
                currentFaceIndex = null;
            }

            if (isDragging) {
                const delta = {
                    x: e.clientX - previousPosition.x,
                    y: e.clientY - previousPosition.y
                };
                sphere.rotation.y += delta.x * 0.01;
                sphere.rotation.x += delta.y * 0.01;
                previousPosition = { x: e.clientX, y: e.clientY };
            }
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onClick(e) {
            const popup = document.getElementById('popup');

            if (currentFaceIndex !== null) {
                if (currentFaceIndex === lastClickedIndex) {
                    popup.style.display = 'none';
                    lastClickedIndex = null;
                } else {
                    popup.style.display = 'block';
                    popup.style.left = `${e.clientX + 15}px`;
                    popup.style.top = `${e.clientY + 15}px`;
                    popup.textContent = `Sector: ${currentFaceIndex}`;
                    lastClickedIndex = currentFaceIndex;
                }
            } else {
                popup.style.display = 'none';
                lastClickedIndex = null;
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>