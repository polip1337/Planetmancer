<!DOCTYPE html>
<html>
<head>
    <title>Spherical Grid Solution</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #controls { position: absolute; top: 10px; left: 10px; z-index: 100; color: white; }
        #popup { position: absolute; background: white; padding: 8px; border: 1px solid #ccc; display: none; }
    </style>
</head>
<body>
<div id="controls">
    <select id="subdivisions">
        <option value="0">20 Faces</option>
        <option value="1">80 Faces</option>
        <option value="2">320 Faces</option>
        <option value="3">1280 Faces</option>
    </select>
</div>
<div id="popup"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
        let scene, camera, renderer, sphere;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isDragging = false;
        let previousPosition = { x: 0, y: 0 };
        let currentFaceIndex = null;

        // Check WebGL support first
        if (!window.WebGLRenderingContext) {
            alert('WebGL is not supported in your browser!');
            throw new Error('WebGL not supported');
        }

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

            try {
                renderer = new THREE.WebGLRenderer({ antialias: true });
            } catch (e) {
                alert('Failed to create WebGL context: ' + e.message);
                return;
            }

            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x333333);
            document.body.appendChild(renderer.domElement);

            // Create initial sphere
            createSphere(1);
            camera.position.z = 15;

            // Lighting
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(1, 1, 1).normalize();
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            // Event listeners
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('click', onClick);
            window.addEventListener('resize', onResize);
            document.getElementById('subdivisions').addEventListener('change', updateSubdivisions);
        }

        function createSphere(subdivisions) {
            if (sphere) {
                scene.remove(sphere);
                sphere.geometry.dispose();
                sphere.material.dispose();
            }

            const geometry = new THREE.IcosahedronGeometry(5, subdivisions);
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                wireframe: false,
                transparent: true,
                opacity: 0.9
            });

            // Generate vertex colors
            const colors = [];
            const count = geometry.attributes.position.count;

            for (let i = 0; i < count; i++) {
                colors.push(
                    Math.random() * 0.5 + 0.5, // R
                    Math.random() * 0.5 + 0.5, // G
                    Math.random() * 0.5 + 0.5  // B
                );
            }

            // Fixed line with proper parentheses
            geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));
            geometry.computeVertexNormals();

            sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);
        }

        // Rest of the functions (updateSubdivisions, event handlers, etc.)
        function updateSubdivisions(e) {
            createSphere(parseInt(e.target.value));
        }

        function onMouseDown(e) {
            isDragging = true;
            previousPosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(sphere);

            if (intersects.length > 0) {
                const newFaceIndex = intersects[0].faceIndex;
                if (currentFaceIndex !== newFaceIndex) {
                    currentFaceIndex = newFaceIndex;
                }
            } else {
                currentFaceIndex = null;
            }

            if (isDragging) {
                const delta = {
                    x: e.clientX - previousPosition.x,
                    y: e.clientY - previousPosition.y
                };
                sphere.rotation.y += delta.x * 0.01;
                sphere.rotation.x += delta.y * 0.01;
                previousPosition = { x: e.clientX, y: e.clientY };
            }
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onClick(e) {
            if (currentFaceIndex !== null) {
                const popup = document.getElementById('popup');
                popup.style.display = 'block';
                popup.style.left = `${e.clientX + 15}px`;
                popup.style.top = `${e.clientY + 15}px`;
                popup.textContent = `Cell Number: ${currentFaceIndex}`;
                setTimeout(() => popup.style.display = 'none', 2000);
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>