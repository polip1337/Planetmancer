<!DOCTYPE html>
<html>
<head>
  <title>Draggable Spherical Grid</title>
  <style>
        body { margin: 0; overflow: hidden; }
        #popup {
            position: absolute;
            background: white;
            padding: 10px;
            border: 1px solid black;
            display: none;
        }
        #textureToggle {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
        }
    </style>
</head>
<body>
<button id="textureToggle">Toggle Texture</button>
<div id="popup"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
        let scene, camera, renderer, sphere;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let currentIntersect = null;
        let useTexture = false;

        init();
        animate();

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Create sphere with explicit geometry groups
            const geometry = new THREE.IcosahedronGeometry(5, 3);

            // Create material groups
            geometry.clearGroups();
            const materials = [];
            for (let i = 0; i < geometry.faces.length; i++) {
                geometry.addGroup(i * 3, 3, i);
                materials.push(new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.5, 0.5),
                    transparent: true,
                    opacity: 0.8,
                    wireframe: false
                }));
            }

            sphere = new THREE.Mesh(geometry, materials);
            scene.add(sphere);

            // Add ambient light
            const light = new THREE.AmbientLight(0xffffff, 1);
            scene.add(light);

            // Position camera
            camera.position.z = 15;

            // Event listeners
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('click', onDocumentClick);
            window.addEventListener('resize', onWindowResize);
            document.getElementById('textureToggle').addEventListener('click', toggleTexture);
        }

        function toggleTexture() {
            useTexture = !useTexture;
            const textureLoader = new THREE.TextureLoader();
            const texturePromise = new Promise((resolve) => {
                textureLoader.load('mars4k.jpg', resolve);
            });

            sphere.material.forEach((mat, index) => {
                if (useTexture) {
                    texturePromise.then(texture => {
                        mat.map = texture;
                        mat.color.set(0xFFFFFF);
                        mat.needsUpdate = true;
                    });
                } else {
                    mat.map = null;
                    mat.color.setHSL(Math.random(), 0.5, 0.5);
                    mat.needsUpdate = true;
                }
            });
        }

        // Rest of the code remains the same as previous version
        // ... (include all other functions from previous code here)

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(sphere);

            if (intersects.length > 0) {
                const faceIndex = intersects[0].faceIndex;
                if (currentIntersect !== faceIndex) {
                    if (currentIntersect !== null) {
                        sphere.material[currentIntersect].opacity = 0.8;
                    }
                    currentIntersect = faceIndex;
                    sphere.material[faceIndex].opacity = 1;
                }
            } else if (currentIntersect !== null) {
                sphere.material[currentIntersect].opacity = 0.8;
                currentIntersect = null;
            }

            if (isDragging) {
                const deltaMove = {
                    x: event.clientX - previousMousePosition.x,
                    y: event.clientY - previousMousePosition.y
                };

                sphere.rotation.y += deltaMove.x * 0.01;
                sphere.rotation.x += deltaMove.y * 0.01;

                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>